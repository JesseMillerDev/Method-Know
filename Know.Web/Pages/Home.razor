@page "/"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Net.Http.Headers
@using Know.Web.Services
@implements IDisposable

@attribute [Authorize]
@inject HttpClient Http
@inject AuthenticationStateProvider AuthStateProvider
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject NavigationManager Navigation
@inject AppState AppState

<PageTitle>Resources</PageTitle>

<div class="flex flex-col md:flex-row gap-8 items-start">
    <!-- Sidebar Filters -->
    <aside class="w-full md:w-64 shrink-0 bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 transition-colors duration-200">
        <!-- Header -->
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-[18px] font-semibold text-slate-900 dark:text-white font-['Inter']">Filters</h2>
            <button @onclick="ResetFilters" class="text-[14px] font-normal text-slate-900 dark:text-slate-300 underline font-['Inter'] hover:text-slate-700 dark:hover:text-white">
                Reset filters
            </button>
        </div>

        <!-- Resource Type Filter -->
        <div class="mb-6">
            <h3 class="text-[16px] font-normal text-slate-900 dark:text-white mb-3 font-['Inter']">Resource Type</h3>
            <div class="space-y-3">
                <label class="flex items-center gap-2 cursor-pointer group">
                    <input type="checkbox" 
                           checked="@(selectedCategories.Contains("Articles"))"
                           @onchange='(e) => ToggleCategory("Articles", e.Value)'
                           class="w-3.5 h-3.5 rounded border-gray-300 dark:border-slate-600 text-slate-900 dark:text-white focus:ring-slate-900 dark:focus:ring-slate-400 bg-white dark:bg-slate-800 transition-colors" />
                    <span class="text-[14px] font-medium text-slate-900 dark:text-slate-300 group-hover:text-slate-700 dark:group-hover:text-white font-['Inter']">Articles</span>
                </label>
                <label class="flex items-center gap-2 cursor-pointer group">
                    <input type="checkbox" 
                           checked="@(selectedCategories.Contains("Tutorials"))"
                           @onchange='(e) => ToggleCategory("Tutorials", e.Value)'
                           class="w-3.5 h-3.5 rounded border-gray-300 dark:border-slate-600 text-slate-900 dark:text-white focus:ring-slate-900 dark:focus:ring-slate-400 bg-white dark:bg-slate-800 transition-colors" />
                    <span class="text-[14px] font-medium text-slate-900 dark:text-slate-300 group-hover:text-slate-700 dark:group-hover:text-white font-['Inter']">Tutorials</span>
                </label>
                <label class="flex items-center gap-2 cursor-pointer group">
                    <input type="checkbox" 
                           checked="@(selectedCategories.Contains("Documentation"))"
                           @onchange='(e) => ToggleCategory("Documentation", e.Value)'
                           class="w-3.5 h-3.5 rounded border-gray-300 dark:border-slate-600 text-slate-900 dark:text-white focus:ring-slate-900 dark:focus:ring-slate-400 bg-white dark:bg-slate-800 transition-colors" />
                    <span class="text-[14px] font-medium text-slate-900 dark:text-slate-300 group-hover:text-slate-700 dark:group-hover:text-white font-['Inter']">Documentation</span>
                </label>
            </div>
        </div>

        <!-- Tags Filter -->
        <div>
            <h3 class="text-[16px] font-normal text-slate-900 dark:text-white mb-3 font-['Inter']">Tags</h3>
            <div class="flex flex-wrap gap-2">
                @foreach (var tag in uniqueTags.Take(15))
                {
                    <button @onclick="() => ToggleTag(tag, !selectedTags.Contains(tag))"
                            class="px-2.5 py-1 rounded-full text-[12px] font-medium transition-colors border @(selectedTags.Contains(tag) ? "bg-slate-900 dark:bg-white text-white dark:text-slate-900 border-slate-900 dark:border-white" : "bg-white dark:bg-slate-800 text-slate-700 dark:text-slate-300 border-slate-200 dark:border-slate-700 hover:border-slate-300 dark:hover:border-slate-600")">
                        @tag
                    </button>
                }
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <div class="flex-1 w-full min-w-0">
        <!-- Header -->
        <div class="mb-6 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
            <div>
                <h1 class="text-[30px] font-semibold tracking-[-0.75px] text-slate-900 dark:text-white font-['Inter'] mb-1">Discover Resources</h1>
                <p class="text-[20px] font-normal text-slate-900 dark:text-slate-300 tracking-[-0.1px] font-['Inter']">Explore shared knowledge from our community</p>
            </div>
            
            <button @onclick="OpenCreateModal" class="shrink-0 flex items-center gap-2 px-4 py-2 bg-slate-900 dark:bg-blue-600 text-white dark:text-white text-sm font-medium rounded-lg hover:bg-slate-800 dark:hover:bg-blue-700 transition-colors shadow-sm hover:shadow">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Add Resource
            </button>
        </div>

        <!-- Loading State & Grid -->
        @if (isLoading)
        {
            <LoadingSpinner Message="Loading resources..." />
        }
        else
        {
            <ResourceGrid 
                Articles="@articles"
                SearchQuery="@searchQuery"
                SelectedCategory="@(selectedCategories.Count > 0 ? string.Join(", ", selectedCategories) : "All")"
                EmptyStateMessage="No resources match your filters."
                OnViewArticle="ViewArticle"
            />
        }
    </div>
</div>

<!-- Resource Modal Component -->
<ResourceModal 
    ShowModal="@showModal"
    IsClosing="@isClosing"
    ModalMode="@modalMode"
    SelectedArticle="@selectedArticle"
    UserId="@userId"
    OnClose="@CloseModal"
    OnArticleCreated="@HandleArticleCreated"
    OnArticleUpdated="@HandleArticleUpdated"
    OnArticleDeleted="@HandleArticleDeleted"
/>

@code {
    private List<Article> articles = new();
    private bool isLoading = true;
    private string searchQuery = "";
    
    // Filters
    private HashSet<string> selectedCategories = new();
    private HashSet<string> selectedTags = new();
    private List<string> uniqueTags = new();

    private string? userId;
    
    // Modal state
    private bool showModal = false;
    private bool isClosing = false;
    private string modalMode = "view"; // "create" or "view"
    private Article? selectedArticle = null;

    protected override async Task OnInitializedAsync()
    {
        AppState.OnSearchChanged += HandleSearchChanged;
        searchQuery = AppState.SearchQuery;

        try
        {
            // Get user ID for creating articles
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user.Identity?.IsAuthenticated == true)
            {
                userId = user.FindFirst("sub")?.Value 
                    ?? user.FindFirst("nameid")?.Value 
                    ?? user.FindFirst("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier")?.Value;
            }
            
            // Get auth token and set authorization header
            var token = await LocalStorage.GetItemAsync<string>("authToken");
            if (!string.IsNullOrEmpty(token))
            {
                Http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
            }
            
            // Fetch all articles
            await RefreshArticles();
            
            // Extract unique tags
            uniqueTags = articles
                .Where(a => a.TagList != null)
                .SelectMany(a => a.TagList)
                .Distinct()
                .OrderBy(t => t)
                .ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading articles: {ex.Message}");
            articles = new();
        }
        finally
        {
            isLoading = false;
        }
    }

    public void Dispose()
    {
        AppState.OnSearchChanged -= HandleSearchChanged;
    }

    private async void HandleSearchChanged(string query)
    {
        searchQuery = query;
        await RefreshArticles();
    }

    private async Task ResetFilters()
    {
        selectedCategories.Clear();
        selectedTags.Clear();
        await RefreshArticles();
    }

    private async Task ToggleCategory(string category, object? isChecked)
    {
        if (isChecked is bool check && check)
        {
            selectedCategories.Add(category);
        }
        else
        {
            selectedCategories.Remove(category);
        }
        await RefreshArticles();
    }

    private async Task ToggleTag(string tag, object? isChecked)
    {
        if (isChecked is bool check && check)
        {
            selectedTags.Add(tag);
        }
        else
        {
            selectedTags.Remove(tag);
        }
        await RefreshArticles();
    }



    private void OpenCreateModal()
    {
        modalMode = "create";
        selectedArticle = null;
        showModal = true;
        isClosing = false;
    }

    private void ViewArticle(int articleId)
    {
        selectedArticle = articles.FirstOrDefault(a => a.Id == articleId);
        if (selectedArticle != null)
        {
            modalMode = "view";
            showModal = true;
            isClosing = false;
        }
    }

    private async Task CloseModal()
    {
        isClosing = true;
        StateHasChanged();
        await Task.Delay(300); // Wait for animation
        showModal = false;
        isClosing = false;
        StateHasChanged();
    }

    private async Task HandleArticleCreated(Article article)
    {
        await RefreshArticles();
    }

    private async Task HandleArticleUpdated(Article article)
    {
        selectedArticle = article;
        await RefreshArticles();
    }

    private async Task HandleArticleDeleted(int articleId)
    {
        if (selectedArticle?.Id == articleId)
        {
            selectedArticle = null;
        }

        await RefreshArticles();
    }

    private async Task RefreshArticles()
    {
        try
        {
            isLoading = true;
            StateHasChanged();

            var queryParams = new List<string>();
            
            foreach (var category in selectedCategories)
            {
                queryParams.Add($"categories={Uri.EscapeDataString(category)}");
            }

            foreach (var tag in selectedTags)
            {
                queryParams.Add($"tags={Uri.EscapeDataString(tag)}");
            }
            
            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                queryParams.Add($"search={Uri.EscapeDataString(searchQuery)}");
            }

            var queryString = queryParams.Any() ? "?" + string.Join("&", queryParams) : "";
            var apiUrl = $"/api/articles{queryString}";

            articles = await Http.GetFromJsonAsync<List<Article>>(apiUrl) ?? new();
            
            // Refresh tags (only if not filtering by tags, or maybe always? 
            // If we filter, we might only get a subset of tags. 
            // Ideally, we want ALL tags for the filter list, which should probably come from a separate endpoint or cache.
            // But for now, let's keep it simple and maybe NOT update uniqueTags on every filter, 
            // or else the filter list will shrink as you filter!
            // The original code updated uniqueTags on every load. 
            // If we want to keep all tags available for filtering, we should probably fetch them once or separately.
            // Let's check if there is a GetTags endpoint. Yes, /api/tags.
            
            // Let's fetch tags separately if the list is empty, or just keep the current behavior 
            // but be aware that filtering might hide other tags.
            // Actually, `uniqueTags` drives the filter UI. If we update it based on *filtered* results, 
            // the user won't be able to select other tags.
            // So we should ONLY update uniqueTags if we are NOT filtering, or fetch them from /api/tags.
            // There is an endpoint `app.MapGet("/api/tags", ...)` in Program.cs.
            // Let's use that to populate the filter list initially!
            
            if (!uniqueTags.Any())
            {
                try 
                {
                    uniqueTags = await Http.GetFromJsonAsync<List<string>>("/api/tags") ?? new();
                }
                catch 
                {
                    // Fallback to extracting from articles if tags endpoint fails or returns empty
                    if (articles.Any())
                    {
                         uniqueTags = articles
                            .Where(a => a.TagList != null)
                            .SelectMany(a => a.TagList)
                            .Distinct()
                            .OrderBy(t => t)
                            .ToList();
                    }
                }
            }
                
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing articles: {ex.Message}");
            articles = new();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }
}
